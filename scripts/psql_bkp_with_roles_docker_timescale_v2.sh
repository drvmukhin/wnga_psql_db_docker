#!/usr/bin/env bash
set -Eeuo pipefail

# PostgreSQL + TimescaleDB Complete Backup Script v2.0
# ---------------------------------------------------------------------------------
# Captures COMPLETE TimescaleDB metadata for exact database replicas including:
#   - Hypertable definitions with chunk intervals
#   - Continuous aggregates with full DDL
#   - Compression settings (segmentby, orderby)
#   - All policies (retention, compression, reorder, refresh)
#   - Space partitioning (multi-dimensional hypertables)
#
# Run this script on the HOST. It exports metadata to multiple files:
#   <db>.bkp                    - Database dump (custom format)
#   <db>.roles                  - Role list
#   <db>.hypertables.sql        - Complete hypertable recreation SQL
#   <db>.continuous_aggs.sql    - Continuous aggregate DDL
#   <db>.compression.sql        - Compression configuration
#   <db>.policies.sql           - All policy definitions
#
# Usage:
#   psql_bkp_with_roles_docker_timescale_v2.sh [-c <container>] [-d <backup_dir>] [-db <database>] [-r <role1,role2,...>] [-q] [-h]
#
# Requirements:
#   - Running Postgres container with TimescaleDB extension
#   - gosu, psql, pg_dump available in container
#   - Write permission to backup directory

CONTAINER="pg17"
BASE_BACKUP_DIR="./backups"
DB_NAME=""
ROLE_FILTER=""
QUIET_MODE=0

print_help() {
  cat <<'EOF'
PostgreSQL + TimescaleDB Complete Backup Script v2.0

Usage:
  psql_bkp_with_roles_docker_timescale_v2.sh [-c <container>] [-d <backup_dir>] [-db <database>] [-r <role1,role2,...>] [-q] [-h]

Flags:
  -c   Docker container name (default: pg17)
  -d   Destination directory on host (default: ./backups)
  -db  Specific database name to back up (default: all user DBs)
  -r   Comma-separated list of roles to export (default: all non-system roles)
  -q   Quiet mode - suppress verbose output
  -h   Help

Examples:
  # Backup single database with TimescaleDB
  ./psql_bkp_with_roles_docker_timescale_v2.sh -c pg17-test -db wnga_auth -d ./backups

  # Backup all databases quietly
  ./psql_bkp_with_roles_docker_timescale_v2.sh -c pg17-test -d /srv/backups -q

  # Backup specific roles only
  ./psql_bkp_with_roles_docker_timescale_v2.sh -c pg17-test -db wnga_auth -r "wnga,admin"
EOF
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c) CONTAINER="$2"; shift 2 ;;
    -d) BASE_BACKUP_DIR="$2"; shift 2 ;;
    -db) DB_NAME="$2"; shift 2 ;;
    -r) ROLE_FILTER="$2"; shift 2 ;;
    -q) QUIET_MODE=1; shift ;;
    -h) print_help ;;
    *) echo "Unknown option: $1" >&2; print_help ;;
  esac
done

# Verify container is running
if ! docker ps --format '{{.Names}}' | grep -qx "$CONTAINER"; then
  echo "‚ùå Container '$CONTAINER' is not running" >&2
  exit 1
fi

# Create backup directory with timestamp
mkdir -p "$BASE_BACKUP_DIR"
CURRENT_DATE=$(date +"%Y_%m_%d")
find_next_backup_dir() {
  local base_dir=$1 date_str=$2 n=0 path
  while true; do
    path="${base_dir}/bkp_${date_str}_${n}"
    [[ ! -d "$path" ]] && { echo "$path"; return; }
    n=$((n+1))
  done
}
BACKUP_DIR=$(find_next_backup_dir "$BASE_BACKUP_DIR" "$CURRENT_DATE")
mkdir -p "$BACKUP_DIR"

echo "=========================================="
echo "PostgreSQL + TimescaleDB Complete Backup"
echo "=========================================="
echo "Backup Directory: $BACKUP_DIR"
echo "Container: $CONTAINER"
echo "Timestamp: $(date)"
echo "=========================================="
echo ""

# Get database list
if [[ -n "$DB_NAME" ]]; then
  mapfile -t DBS < <(printf '%s\n' "$DB_NAME")
else
  mapfile -t DBS < <(docker exec -i "$CONTAINER" gosu postgres psql -d postgres -At -c \
    "SELECT datname FROM pg_database WHERE datistemplate = false AND datname != 'postgres' ORDER BY 1;")
fi

# Check if database has TimescaleDB
check_timescaledb() {
  local db="$1"
  docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At -c \
    "SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname = 'timescaledb');" 2>/dev/null || echo "f"
}

# Export roles
export_roles() {
  local db="$1" out_file="$2"
  if [[ -n "$ROLE_FILTER" ]]; then
    IFS=',' read -ra ROLES <<<"$ROLE_FILTER"
    printf '%s\n' "${ROLES[@]}" | sed '/^$/d' | paste -sd ', ' - > "$out_file"
  else
    docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At -c \
      "SELECT string_agg(rolname, ', ') 
       FROM pg_roles 
       WHERE rolname !~ '^pg_' AND rolname <> 'postgres';" > "$out_file"
  fi
}

# Export complete hypertable metadata as SQL
export_hypertables_sql() {
  local db="$1" out_file="$2"
  
  docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At <<'EOSQL' > "$out_file"
-- Hypertable recreation SQL
-- Generated by psql_bkp_with_roles_docker_timescale_v2.sh

SELECT 
  '-- Hypertable: ' || format('%I.%I', h.schema_name, h.table_name) || E'\n' ||
  'SELECT create_hypertable(' || E'\n' ||
  '  ' || quote_literal(format('%I.%I', h.schema_name, h.table_name)) || ',' || E'\n' ||
  '  ' || quote_literal(d.column_name) || ',' || E'\n' ||
  '  chunk_time_interval => ' || d.interval_length || ',' || E'\n' ||
  '  if_not_exists => true,' || E'\n' ||
  '  migrate_data => true' || E'\n' ||
  ');' || E'\n'
FROM _timescaledb_catalog.hypertable h
JOIN _timescaledb_catalog.dimension d ON h.id = d.hypertable_id
WHERE h.schema_name NOT LIKE '_timescaledb_%'
  AND d.interval_length IS NOT NULL
ORDER BY h.schema_name, h.table_name;
EOSQL

  # Add space partitioning info if exists
  docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At <<'EOSQL' >> "$out_file" 2>/dev/null || true
-- Space partitions (if any)
SELECT 
  '-- Add space partition to: ' || format('%I.%I', h.schema_name, h.table_name) || E'\n' ||
  'SELECT add_dimension(' || E'\n' ||
  '  ' || quote_literal(format('%I.%I', h.schema_name, h.table_name)) || ',' || E'\n' ||
  '  ' || quote_literal(d.column_name) || ',' || E'\n' ||
  '  number_partitions => ' || COALESCE(d.num_slices, 4) || E'\n' ||
  ');' || E'\n'
FROM _timescaledb_catalog.hypertable h
JOIN _timescaledb_catalog.dimension d ON h.id = d.hypertable_id
WHERE h.schema_name NOT LIKE '_timescaledb_%'
  AND d.interval_length IS NULL  -- Space dimensions have no interval
ORDER BY h.schema_name, h.table_name;
EOSQL
}

# Export continuous aggregates with full DDL
export_continuous_aggregates_sql() {
  local db="$1" out_file="$2"
  
  docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At <<'EOSQL' > "$out_file"
-- Continuous Aggregates recreation SQL
-- Generated by psql_bkp_with_roles_docker_timescale_v2.sh
-- NOTE: These must be recreated AFTER hypertables are restored

SELECT 
  '-- Continuous Aggregate: ' || format('%I.%I', view_schema, view_name) || E'\n' ||
  'CREATE MATERIALIZED VIEW ' || format('%I.%I', view_schema, view_name) || E'\n' ||
  'WITH (timescaledb.continuous) AS' || E'\n' ||
  view_definition || ';' || E'\n'
FROM timescaledb_information.continuous_aggregates
ORDER BY view_schema, view_name;
EOSQL
}

# Export compression settings
export_compression_sql() {
  local db="$1" out_file="$2"
  
  docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At <<'EOSQL' > "$out_file"
-- Compression settings SQL
-- Generated by psql_bkp_with_roles_docker_timescale_v2.sh

SELECT 
  '-- Enable compression on: ' || format('%I.%I', t.schema_name, t.table_name) || E'\n' ||
  'ALTER TABLE ' || format('%I.%I', t.schema_name, t.table_name) || E'\n' ||
  'SET (' || E'\n' ||
  '  timescaledb.compress = true' ||
  CASE 
    WHEN array_length(t.segmentby_cols, 1) > 0 THEN 
      ',' || E'\n' || '  timescaledb.compress_segmentby = ' || 
      quote_literal(array_to_string(t.segmentby_cols, ','))
    ELSE ''
  END ||
  CASE 
    WHEN array_length(t.orderby_cols, 1) > 0 THEN 
      ',' || E'\n' || '  timescaledb.compress_orderby = ' || 
      quote_literal(array_to_string(t.orderby_cols, ','))
    ELSE ''
  END || E'\n' ||
  ');' || E'\n'
FROM (
  SELECT 
    h.schema_name,
    h.table_name,
    cs.segmentby as segmentby_cols,
    ARRAY(
      SELECT orderby[i] || 
        CASE WHEN orderby_desc[i] THEN ' DESC' ELSE ' ASC' END
      FROM generate_subscripts(cs.orderby, 1) i
    ) as orderby_cols
  FROM _timescaledb_catalog.hypertable h
  LEFT JOIN _timescaledb_catalog.compression_settings cs 
    ON format('%I.%I', h.schema_name, h.table_name)::regclass = cs.relid
  WHERE h.compression_state > 0
    AND h.schema_name NOT LIKE '_timescaledb_%'
) t
ORDER BY t.schema_name, t.table_name;
EOSQL
}

# Export all policies (retention, compression, reorder, refresh)
export_policies_sql() {
  local db="$1" out_file="$2"
  
  docker exec -i "$CONTAINER" gosu postgres psql -d "$db" -At <<'EOSQL' > "$out_file"
-- Policy definitions SQL
-- Generated by psql_bkp_with_roles_docker_timescale_v2.sh

-- Retention policies
SELECT 
  '-- Retention policy for: ' || format('%I.%I', ht.schema_name, ht.table_name) || E'\n' ||
  'SELECT add_retention_policy(' || E'\n' ||
  '  ' || quote_literal(format('%I.%I', ht.schema_name, ht.table_name)) || ',' || E'\n' ||
  '  drop_after => INTERVAL ' || quote_literal(config->>'drop_after') || ',' || E'\n' ||
  '  if_not_exists => true' || E'\n' ||
  ');' || E'\n'
FROM _timescaledb_config.bgw_job j
JOIN _timescaledb_catalog.hypertable ht ON j.hypertable_id = ht.id
WHERE j.proc_schema = '_timescaledb_functions' 
  AND j.proc_name = 'policy_retention'
  AND ht.schema_name NOT LIKE '_timescaledb_%'
ORDER BY ht.schema_name, ht.table_name;

-- Compression policies
SELECT 
  '-- Compression policy for: ' || format('%I.%I', ht.schema_name, ht.table_name) || E'\n' ||
  'SELECT add_compression_policy(' || E'\n' ||
  '  ' || quote_literal(format('%I.%I', ht.schema_name, ht.table_name)) || ',' || E'\n' ||
  '  compress_after => INTERVAL ' || quote_literal(config->>'compress_after') || ',' || E'\n' ||
  '  if_not_exists => true' || E'\n' ||
  ');' || E'\n'
FROM _timescaledb_config.bgw_job j
JOIN _timescaledb_catalog.hypertable ht ON j.hypertable_id = ht.id
WHERE j.proc_schema = '_timescaledb_functions' 
  AND j.proc_name = 'policy_compression'
  AND ht.schema_name NOT LIKE '_timescaledb_%'
ORDER BY ht.schema_name, ht.table_name;

-- Continuous aggregate refresh policies
SELECT 
  '-- Refresh policy for continuous aggregate: ' || format('%I.%I', view_schema, view_name) || E'\n' ||
  'SELECT add_continuous_aggregate_policy(' || E'\n' ||
  '  ' || quote_literal(format('%I.%I', view_schema, view_name)) || ',' || E'\n' ||
  '  start_offset => INTERVAL ' || quote_literal(config->>'start_offset') || ',' || E'\n' ||
  '  end_offset => INTERVAL ' || quote_literal(config->>'end_offset') || ',' || E'\n' ||
  '  schedule_interval => INTERVAL ' || quote_literal(
    extract(epoch from schedule_interval)::text || ' seconds'
  ) || ',' || E'\n' ||
  '  if_not_exists => true' || E'\n' ||
  ');' || E'\n'
FROM _timescaledb_config.bgw_job j
JOIN timescaledb_information.continuous_aggregates ca 
  ON j.hypertable_id = (
    SELECT id FROM _timescaledb_catalog.hypertable 
    WHERE schema_name = ca.materialization_hypertable_schema 
    AND table_name = ca.materialization_hypertable_name
  )
WHERE j.proc_schema = '_timescaledb_functions' 
  AND j.proc_name = 'policy_refresh_continuous_aggregate'
ORDER BY ca.view_schema, ca.view_name;
EOSQL
}

# Perform backup for each database
for DB in "${DBS[@]}"; do
  DB_TRIMMED=$(echo "$DB" | xargs)
  [[ -z "$DB_TRIMMED" ]] && continue
  
  echo "========================================"
  echo "üì¶ Backing up: $DB_TRIMMED"
  echo "========================================"
  
  HAS_TIMESCALEDB=$(check_timescaledb "$DB_TRIMMED")
  
  if [[ "$HAS_TIMESCALEDB" == "t" ]]; then
    echo "‚è∞ TimescaleDB detected - exporting complete metadata"
    
    # Export hypertables
    echo "  üìä Exporting hypertable definitions..."
    export_hypertables_sql "$DB_TRIMMED" "$BACKUP_DIR/${DB_TRIMMED}.hypertables.sql"
    HT_COUNT=$(grep -c "SELECT create_hypertable" "$BACKUP_DIR/${DB_TRIMMED}.hypertables.sql" 2>/dev/null || echo "0")
    echo "     ‚úì $HT_COUNT hypertable(s) exported"
    
    # Export continuous aggregates
    echo "  üìä Exporting continuous aggregates..."
    export_continuous_aggregates_sql "$DB_TRIMMED" "$BACKUP_DIR/${DB_TRIMMED}.continuous_aggs.sql"
    CAGG_COUNT=$(grep -c "CREATE MATERIALIZED VIEW" "$BACKUP_DIR/${DB_TRIMMED}.continuous_aggs.sql" 2>/dev/null || echo "0")
    echo "     ‚úì $CAGG_COUNT continuous aggregate(s) exported"
    
    # Export compression settings
    echo "  üìä Exporting compression settings..."
    export_compression_sql "$DB_TRIMMED" "$BACKUP_DIR/${DB_TRIMMED}.compression.sql"
    COMP_COUNT=$(grep -c "ALTER TABLE" "$BACKUP_DIR/${DB_TRIMMED}.compression.sql" 2>/dev/null || echo "0")
    echo "     ‚úì $COMP_COUNT compressed hypertable(s) exported"
    
    # Export policies
    echo "  üìä Exporting policies..."
    export_policies_sql "$DB_TRIMMED" "$BACKUP_DIR/${DB_TRIMMED}.policies.sql"
    POL_COUNT=$(grep -c "SELECT add_" "$BACKUP_DIR/${DB_TRIMMED}.policies.sql" 2>/dev/null || echo "0")
    echo "     ‚úì $POL_COUNT policy/policies exported"
    
    # Create database dump (excludes TimescaleDB internal schemas and continuous aggregate views)
    echo "  üíæ Creating database dump..."
    
    # Get list of continuous aggregate view names to exclude
    CAGG_VIEWS=$(docker exec -i "$CONTAINER" gosu postgres psql -d "$DB_TRIMMED" -At -c \
      "SELECT format('--exclude-table=%I.%I', view_schema, view_name) 
       FROM timescaledb_information.continuous_aggregates;" 2>/dev/null | tr '\n' ' ' || echo "")
    
    if [[ $QUIET_MODE -eq 1 ]]; then
      docker exec -i "$CONTAINER" gosu postgres pg_dump \
        -F c -b \
        --exclude-schema='_timescaledb_catalog' \
        --exclude-schema='_timescaledb_config' \
        --exclude-schema='_timescaledb_cache' \
        --exclude-schema='_timescaledb_internal' \
        $CAGG_VIEWS \
        --no-publications \
        --no-subscriptions \
        -d "$DB_TRIMMED" > "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>/dev/null
    else
      docker exec -i "$CONTAINER" gosu postgres pg_dump \
        -F c -b \
        --exclude-schema='_timescaledb_catalog' \
        --exclude-schema='_timescaledb_config' \
        --exclude-schema='_timescaledb_cache' \
        --exclude-schema='_timescaledb_internal' \
        $CAGG_VIEWS \
        --no-publications \
        --no-subscriptions \
        -d "$DB_TRIMMED" > "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>&1
    fi
  else
    echo "üìã Standard PostgreSQL database"
    echo "  üíæ Creating database dump..."
    if [[ $QUIET_MODE -eq 1 ]]; then
      docker exec -i "$CONTAINER" gosu postgres pg_dump \
        -F c -b \
        -d "$DB_TRIMMED" > "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>/dev/null
    else
      docker exec -i "$CONTAINER" gosu postgres pg_dump \
        -F c -b \
        -d "$DB_TRIMMED" > "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>&1
    fi
  fi
  
  # Verify backup file was created
  if [[ ! -f "$BACKUP_DIR/${DB_TRIMMED}.bkp" ]]; then
    echo "  ‚ùå ERROR: Backup file was not created!" >&2
    continue
  fi
  
  BACKUP_SIZE=$(du -h "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>/dev/null | cut -f1)
  BACKUP_BYTES=$(stat -c%s "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>/dev/null || stat -f%z "$BACKUP_DIR/${DB_TRIMMED}.bkp" 2>/dev/null || echo "0")
  
  if [[ "$BACKUP_BYTES" -eq 0 ]]; then
    echo "  ‚ùå ERROR: Backup file is empty (0 bytes)!" >&2
    continue
  fi
  
  echo "     ‚úì Backup file created successfully"
  
  # Count tables in backup (query database directly for accurate count)
  TABLE_COUNT=$(docker exec -i "$CONTAINER" gosu postgres psql -d "$DB_TRIMMED" -At -c \
    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema NOT IN ('pg_catalog', 'information_schema', '_timescaledb_catalog', '_timescaledb_config', '_timescaledb_cache', '_timescaledb_internal');" 2>/dev/null || echo "0")
  if [[ "$TABLE_COUNT" -gt 0 ]]; then
    echo "     ‚úì Total tables backed up: $TABLE_COUNT"
  fi
  
  # Export roles
  echo "  üë• Exporting roles for: $DB_TRIMMED"
  export_roles "$DB_TRIMMED" "$BACKUP_DIR/${DB_TRIMMED}.roles"
  
  if [[ -f "$BACKUP_DIR/${DB_TRIMMED}.roles" ]]; then
    ROLE_LIST=$(cat "$BACKUP_DIR/${DB_TRIMMED}.roles")
    if [[ -n "$ROLE_LIST" ]]; then
      echo "     ‚úì Roles exported: $ROLE_LIST"
    else
      echo "     ‚ö† No roles found to export"
    fi
  fi
  
  # Final status with TimescaleDB indicator
  if [[ "$HAS_TIMESCALEDB" == "t" ]]; then
    echo "  ‚úÖ Backup completed for: $DB_TRIMMED (size: $BACKUP_SIZE) ‚è∞"
  else
    echo "  ‚úÖ Backup completed for: $DB_TRIMMED (size: $BACKUP_SIZE)"
  fi
  echo ""
done

# Create backup manifest
echo "üìã Creating backup manifest..."
cat > "$BACKUP_DIR/BACKUP_MANIFEST.txt" <<EOF
PostgreSQL + TimescaleDB Complete Backup
=========================================
Created: $(date)
Container: $CONTAINER
Backup Directory: $BACKUP_DIR

Databases Backed Up:
EOF

for DB in "${DBS[@]}"; do
  DB_TRIMMED=$(echo "$DB" | xargs)
  [[ -z "$DB_TRIMMED" ]] && continue
  
  echo "" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
  echo "Database: $DB_TRIMMED" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
  
  if [[ -f "$BACKUP_DIR/${DB_TRIMMED}.bkp" ]]; then
    SIZE=$(du -h "$BACKUP_DIR/${DB_TRIMMED}.bkp" | cut -f1)
    echo "  - ${DB_TRIMMED}.bkp: $SIZE" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
  fi
  
  HAS_TS=$(check_timescaledb "$DB_TRIMMED")
  if [[ "$HAS_TS" == "t" ]]; then
    echo "  - TimescaleDB: YES" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
    [[ -f "$BACKUP_DIR/${DB_TRIMMED}.hypertables.sql" ]] && \
      echo "    ‚úì Hypertables metadata: ${DB_TRIMMED}.hypertables.sql" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
    [[ -f "$BACKUP_DIR/${DB_TRIMMED}.continuous_aggs.sql" ]] && \
      echo "    ‚úì Continuous aggregates: ${DB_TRIMMED}.continuous_aggs.sql" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
    [[ -f "$BACKUP_DIR/${DB_TRIMMED}.compression.sql" ]] && \
      echo "    ‚úì Compression settings: ${DB_TRIMMED}.compression.sql" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
    [[ -f "$BACKUP_DIR/${DB_TRIMMED}.policies.sql" ]] && \
      echo "    ‚úì Policies: ${DB_TRIMMED}.policies.sql" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
  else
    echo "  - TimescaleDB: NO" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
  fi
  
  [[ -f "$BACKUP_DIR/${DB_TRIMMED}.roles" ]] && \
    echo "  - Roles: ${DB_TRIMMED}.roles" >> "$BACKUP_DIR/BACKUP_MANIFEST.txt"
done

echo ""
echo "=========================================="
echo "‚úÖ Backup Complete!"
echo "=========================================="
echo ""
echo "üéâ All done. Files in: $BACKUP_DIR"
echo ""
echo "üìã Backup Summary:"
echo "   Location: $BACKUP_DIR"
echo "   Container: $CONTAINER"
echo "   Databases: ${#DBS[@]}"
echo ""

# List all backed up databases with sizes
for DB in "${DBS[@]}"; do
  DB_TRIMMED=$(echo "$DB" | xargs)
  [[ -z "$DB_TRIMMED" ]] && continue
  
  if [[ -f "$BACKUP_DIR/${DB_TRIMMED}.bkp" ]]; then
    SIZE=$(du -h "$BACKUP_DIR/${DB_TRIMMED}.bkp" | cut -f1)
    HAS_TS=$(check_timescaledb "$DB_TRIMMED")
    if [[ "$HAS_TS" == "t" ]]; then
      echo "   - ${DB_TRIMMED}.bkp: $SIZE ‚è∞"
    else
      echo "   - ${DB_TRIMMED}.bkp: $SIZE"
    fi
  fi
done

echo ""
echo "Files created for each database:"
echo "  - <db>.bkp                 # Database dump"
echo "  - <db>.roles               # Role list"
echo "  - <db>.hypertables.sql     # Hypertable definitions (if TimescaleDB)"
echo "  - <db>.continuous_aggs.sql # Continuous aggregates (if any)"
echo "  - <db>.compression.sql     # Compression settings (if any)"
echo "  - <db>.policies.sql        # All policies (if any)"
echo ""
echo "To restore: Use psql_restore_ts_db_with_roles_compose_v2.sh"
echo "=========================================="
